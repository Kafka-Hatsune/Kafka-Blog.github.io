<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>logisim基础</title>
      <link href="/2023/01/08/%E8%AE%A1%E7%BB%84/logisim%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/01/08/%E8%AE%A1%E7%BB%84/logisim%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Logisim学习笔记"><a href="#Logisim学习笔记" class="headerlink" title="Logisim学习笔记"></a>Logisim学习笔记</h1><h2 id="常用元器件"><a href="#常用元器件" class="headerlink" title="常用元器件"></a>常用元器件</h2><h3 id="Gates-门"><a href="#Gates-门" class="headerlink" title="Gates 门"></a>Gates 门</h3><h4 id="1-Odd-Parity-奇校验-x2F-Even-Parity-偶校验"><a href="#1-Odd-Parity-奇校验-x2F-Even-Parity-偶校验" class="headerlink" title="1.Odd Parity 奇校验&#x2F;Even Parity 偶校验"></a>1.Odd Parity 奇校验&#x2F;Even Parity 偶校验</h4><p>对于奇校验，若数据中有奇数个“1”，则校验结果为1，若数据中有偶数个“1”，则校验结果为0； 对于偶校验，若数据中有偶数个“1”，则校验结果为1，若数据中有奇数个“1”，则校验结果为0。</p><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081604500.png" alt="img"></p><h4 id="2-Controlled-Buffer-受控缓冲器-x2F-三态门"><a href="#2-Controlled-Buffer-受控缓冲器-x2F-三态门" class="headerlink" title="2.Controlled Buffer 受控缓冲器&#x2F;三态门"></a>2.Controlled Buffer 受控缓冲器&#x2F;三态门</h4><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081607286.png" alt="img"></p><h3 id="Plexers-复用器"><a href="#Plexers-复用器" class="headerlink" title="Plexers 复用器"></a>Plexers 复用器</h3><h4 id="1-Multiplexer-多路选择器-MUX"><a href="#1-Multiplexer-多路选择器-MUX" class="headerlink" title="1.Multiplexer 多路选择器 MUX"></a>1.Multiplexer 多路选择器 <strong>MUX</strong></h4><p>​        多路选择器将西面端口的输入复制到东面输出（多输入，一输出）。要输出哪个值是通过元件下端输入端口接收到的值确定的。</p><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081604507.png" alt="图1 多路选择器示例"></p><h4 id="2-Demultiplexer-解复用器-DMX"><a href="#2-Demultiplexer-解复用器-DMX" class="headerlink" title="2.Demultiplexer 解复用器 DMX"></a>2.Demultiplexer 解复用器 <strong>DMX</strong></h4><p>​        将西面边缘的输入复制到东面边缘的某个输出，是输出中哪一个是通过南侧的输入接收到的值指定的。</p><p>常用来写寄存器数据（给定一个地址输入信号，指定寄存器堆中的一个作为写入的目标寄存器</p><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081607490.png" alt="图2 解复用器示例"></p><h5 id="Three-state-三态选项"><a href="#Three-state-三态选项" class="headerlink" title="Three-state?三态选项"></a>Three-state?三态选项</h5><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081609348.png"><p>三态未开，DMX默认未被复制端为0，可输出</p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081604515.png" alt="image-20221002092347159" style="zoom: 67%;" /><p>三态开，DMX默认未被复制端为x，不可输出</p><h4 id="3-Decoder-译码器-Decd"><a href="#3-Decoder-译码器-Decd" class="headerlink" title="3.Decoder 译码器 Decd"></a>3.Decoder 译码器 Decd</h4><p>​       输出端从上到下编号，第一个编号为0。如果输出端的编号与当前通过南部的选择输入接收到的值相等，则这个端口的输出将为1，否则，它的值将是0或浮动，这取决于Three-State?（是否三态）属性。如果选择输入包含任何未指定的位，则所有输出都是浮动的。</p><p>三态功能同上</p><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081605460.png" alt="图3 译码器示例"></p><p><strong>真正的作用是将二进制编码转换为独热码。</strong></p><h4 id="4-Pirority-Encoder-优先编码器-Pri"><a href="#4-Pirority-Encoder-优先编码器-Pri" class="headerlink" title="4.Pirority Encoder 优先编码器 Pri"></a>4.Pirority Encoder 优先编码器 <strong>Pri</strong></h4><p>​        组件在其西边有多个输入，第一个输入编号为0，从上往下编号。该组件寻找值为1的输入的编号，并输出值最大的编号。例如，如果输入端编号为0、2、5和6的输入都是1，那么优先级编码器将输出 110（也就是编号6的二进制表示）。如果没有输入为1，或者组件被禁用，那么优先级编码器的输出是浮动的。</p><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081608536.png" alt="图4 优先编码器示例"></p><h4 id="5-Bit-Selector-位选择器-Sel"><a href="#5-Bit-Selector-位选择器-Sel" class="headerlink" title="5.Bit Selector 位选择器 Sel"></a>5.Bit Selector 位选择器 Sel</h4><p>​        给定一个 n 位的输入，将把输入分成几个大小相等的组(从最低阶位开始)。如果输出为 m 位，则一共分成 <img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081614558.gif" alt="\left \lceil \frac{n}{m} \right \rceil"> 组（但是编号从 0 开始），并输出选择输入所选择的组。(为什么公式lceil炫不出来？)<br> 例如，如果我们有一个 8 位的输入01010101，而我们要有一个 3 位的输出，那么8&#x2F;3向上取余&#x3D;3。0 组将是最低阶的 3 位 101，1 组将是接下来的 3 位 010，2 组将是接下来的 3 位 001（顶部以外的位用0填充)。选择输入的位宽将是 2，选择这三组中的哪一组输出，但如果选择输入是3，那么将输出 000</p><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081610902.png" alt="图5 位选择器示例"></p><h3 id="Arithmetic-运算器（部分）"><a href="#Arithmetic-运算器（部分）" class="headerlink" title="Arithmetic 运算器（部分）"></a>Arithmetic 运算器（部分）</h3><h4 id="1-Negator-取反器"><a href="#1-Negator-取反器" class="headerlink" title="1.Negator 取反器"></a>1.Negator 取反器</h4><p><strong>取输入的相反数补码输出</strong></p><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081605737.png" alt="img"></p><h4 id="2-Shifter-移位器"><a href="#2-Shifter-移位器" class="headerlink" title="2.Shifter 移位器"></a>2.Shifter 移位器</h4><p>逻辑左移</p><pre><code>    数据中的所有位向左移动 dist 位，底部空出的位用 0 填充。例如，11001011逻辑左移两次就是00101100（之前的右边两位丢弃）</code></pre><p>逻辑右移</p><pre><code>    数据中的所有位向右移动 dist 位，左端空出的位用 0 填充。例如，11001011逻辑右移两次就是00110010（之前的左边两位丢弃)</code></pre><p>算术右移</p><pre><code>    数据中的所有位向右移动 dist 位，左端空出的位用数据中最高位重复填充。例如，11001011算术右移两次就是11110010（之前最高位为 1，所以用 1 填充）</code></pre><p>循环左移</p><pre><code>    数据中的所有位都向左移动 dist 位，左边被“挤出去”的位填充到右边空出的位。例如，将11001011循环左移两次就是00101111。</code></pre><p>循环右移</p><pre><code>    数据中的所有位都向右移动 dist 位，右边被“挤出去”的位填充到左边空出的位。例如，将11001011循环右移两次就是11110010。</code></pre><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081604507.png" alt="img"></p><h4 id="3-Bit-Adder-逐位加法器"><a href="#3-Bit-Adder-逐位加法器" class="headerlink" title="3.Bit Adder 逐位加法器"></a>3.Bit Adder 逐位加法器</h4><p><strong>常用来计算输入中1位&#x2F;0位的数量</strong></p><p>逐位加法器计算并输出：输入中有多少位是<strong>1</strong>。</p><p>例如，给定8位输入10011101，输出将是5，因为在输入中有5个1位(第一个，最后一个，以及中间的一个由3位组成的字符串)。</p><p>逐位加法器可以有多个输入，表示多个输入中位为1的数量的总和</p><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081605920.png" alt="img"></p><h4 id="4-Bit-Finder-位查找器"><a href="#4-Bit-Finder-位查找器" class="headerlink" title="4.Bit Finder 位查找器"></a>4.Bit Finder 位查找器</h4><p><strong>功能：找位</strong></p><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081610809.png" alt="image-20221002095017254"></p><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081610656.png" alt="img"></p><h2 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h2><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081620872.png" alt="image-20220924153534626"></p><p>要点：</p><h3 id="Mealy型和Moore型"><a href="#Mealy型和Moore型" class="headerlink" title="Mealy型和Moore型"></a>Mealy型和Moore型</h3><h4 id="状态转移-x2F-次态逻辑无需考虑Mealy和Moore型的区别。"><a href="#状态转移-x2F-次态逻辑无需考虑Mealy和Moore型的区别。" class="headerlink" title="状态转移&#x2F;次态逻辑无需考虑Mealy和Moore型的区别。"></a>状态转移&#x2F;次态逻辑无需考虑Mealy和Moore型的区别。</h4><p>二者在输出逻辑上产生不同。</p><p>Mealy型输出逻辑：输出是状态和输入的函数。</p><p>Moore型输出逻辑：输出仅是状态的函数。</p><h4 id="Mealy-or-Moore"><a href="#Mealy-or-Moore" class="headerlink" title="Mealy or Moore?"></a>Mealy or Moore?</h4><p>Mealy型：输出窄、输出早。</p><p>以verilog指令为例: (state &#x3D;&#x3D; &#96;S3 &amp;&amp; input &#x3D;&#x3D; 1) ? 1:-1;</p><p>Moore型：输出信号宽。</p><p>以verilog指令为例: (state &#x3D;&#x3D; &#96;S4) ? 1:-1;</p><p>总结：</p><p>对输出信号宽度有要求：Moore型。</p><p>对输出信号时间有要求（越早越好）:Mealy型。</p><h2 id="使用时序电路实现函数计算"><a href="#使用时序电路实现函数计算" class="headerlink" title="使用时序电路实现函数计算"></a>使用时序电路实现函数计算</h2><p>常用形式为F(n)&#x3D;S(F(n-1),F(n-2),······)。思路是将当前值存在寄存器中，下一周期更新等价于实现一次推移。</p><p>以计算S(x) &#x3D; S(x-1) + S(x-2)&amp;S(x-3) 为例</p><h3 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h3><p>思想是S(x)在下一周期变为S(x-1),S(x-1)在下一周期变为S(x-2)…….依次类推。只存储需要用到的状态。（如题，用到S(x-1)，S(x-2)，S(x-3)）</p><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081605064.png" alt="image-20221003214013481"></p><h3 id="状态更新"><a href="#状态更新" class="headerlink" title="状态更新"></a>状态更新</h3><p>状态更新必然是组合逻辑。在三个计算状态更新后现状态应即可更新，等待下一次时钟沿的存储。</p><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081605566.png" alt="image-20221003214323092"></p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>相当于从负下标开始，逐步赋值。第一个周期，x&#x3D;0。后S(x)-&gt;S(x-1)，S(x-1)-&gt;S(x-2)，S(x-2)-&gt;S(x-3),</p><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081610987.png" alt="image-20221003214451581"></p><h2 id="常用组件搭配"><a href="#常用组件搭配" class="headerlink" title="常用组件搭配"></a>常用组件搭配</h2><h3 id="复位"><a href="#复位" class="headerlink" title="复位"></a>复位</h3><h4 id="异步复位"><a href="#异步复位" class="headerlink" title="异步复位"></a>异步复位</h4><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081611107.jpg" alt="Logisim异步复位到0"></p><p>当CLR（clear）为1时，reg直接变成0。</p><h4 id="同步复位"><a href="#同步复位" class="headerlink" title="同步复位"></a>同步复位</h4><h5 id="方式1：MUX接收同步reset信号"><a href="#方式1：MUX接收同步reset信号" class="headerlink" title="方式1：MUX接收同步reset信号"></a>方式1：MUX接收同步reset信号</h5><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081605749.jpg" alt="Logisim同步复位"></p><p>要求“在clk上升沿时复位”。</p><p>例：fsm</p><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081605365.png" alt="image-20221002101255735"></p><h5 id="方式2-寄存器实现reset信号与clk信号同频"><a href="#方式2-寄存器实现reset信号与clk信号同频" class="headerlink" title="方式2:寄存器实现reset信号与clk信号同频"></a>方式2:寄存器实现reset信号与clk信号同频</h5><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081605586.png" alt="image.png"></p><h3 id="赋初始值"><a href="#赋初始值" class="headerlink" title="赋初始值"></a>赋初始值</h3><p>有赋初始值需要的电路，通常认为第一个周期是赋初始值（注意各模块的同频），之后的周期进行运算。</p><h4 id="方式1：计数器-MUX"><a href="#方式1：计数器-MUX" class="headerlink" title="方式1：计数器+MUX"></a>方式1：计数器+MUX</h4><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081611218.png" alt="image-20221003184927702"></p><p>注意counter的设置。</p><h3 id="在输出正确结果前输出0，在得到正确结果后保持输出"><a href="#在输出正确结果前输出0，在得到正确结果后保持输出" class="headerlink" title="在输出正确结果前输出0，在得到正确结果后保持输出"></a>在输出正确结果前输出0，在得到正确结果后保持输出</h3><h4 id="在得到正确结果后保持输出"><a href="#在得到正确结果后保持输出" class="headerlink" title="在得到正确结果后保持输出"></a>在得到正确结果后保持输出</h4><p>增加计数模块</p><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081611950.png" alt="image-20221003210324794"></p><p>在周期数小于x时输出0，在周期数<strong>大于等于</strong>x时输出1。应注意比较器默认为有符号比较，一般需要调至无符号比较。</p><p>有两种选择：</p><ol><li>冻结计算逻辑寄存器(freeze信号传入计算逻辑，当周期到达后freeze反转传入寄存器使能端（默认传入冻结信号为1，使能端为0冻结）)</li><li>冻结输出MUX中的输入信号值，实现较为复杂。因为计数是在大于等于时freeze输出1，所以要保证freeze信号转为1时，传入信号仍能被更新进入MUX，下一周期才冻结。</li></ol><h4 id="在输出正确结果前输出0"><a href="#在输出正确结果前输出0" class="headerlink" title="在输出正确结果前输出0"></a>在输出正确结果前输出0</h4><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081611172.png" alt="image-20221003215129699"></p><p>只需让freeze在第x周期前为0，在第x周期及之后为1即可。用上文计数模块实现。</p><p>input的freeze需到计算逻辑中，增加freeze输入，放到寄存器使能端（记得取反）。</p><h2 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h2><h3 id="1-增加输入个数应同-2x"><a href="#1-增加输入个数应同-2x" class="headerlink" title="1.增加输入个数应同+2x"></a>1.增加输入个数应同+2x</h3><p>比如一个与门，现在有三个输入口，那么现在有增加指令的需求，三个输入口已不能满足需要，应增加输入，这时应增加为5个，可以避免重新接线。</p><p>同理，2个输入口应增加为4个&#x2F;6个</p><h3 id="2-善用Tunnel"><a href="#2-善用Tunnel" class="headerlink" title="2.善用Tunnel"></a>2.善用Tunnel</h3><p>可读性++</p><h3 id="3-善用快捷键"><a href="#3-善用快捷键" class="headerlink" title="3.善用快捷键"></a>3.善用快捷键</h3><p>数字键1-9输入引脚数</p><p>ctrl+1-9工具切换</p><p>alt+1-9位宽切换</p>]]></content>
      
      
      <categories>
          
          <category> BUAA课程学习 </category>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA_CO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>verilog基础</title>
      <link href="/2023/01/07/%E8%AE%A1%E7%BB%84/verilog%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/01/07/%E8%AE%A1%E7%BB%84/verilog%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h1><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><h4 id="未声明进制"><a href="#未声明进制" class="headerlink" title="未声明进制"></a>未声明进制</h4><p>默认十进制，一律被认为是有符号数。</p><h4 id="声明进制"><a href="#声明进制" class="headerlink" title="声明进制"></a>声明进制</h4><p>不声明符号则为无符号数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">8&#x27;sh51 //8位有符号数01010001</span><br><span class="line">6&#x27;so72 //6位有符号数111010，即十进制数下的-6</span><br><span class="line">4&#x27;d2 //4位无符号数</span><br><span class="line">&#x27;hAF //32位16进制数，无符号。注意未声明长度的，统一按32位长度处理</span><br></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>wire、reg不声明signed即为无符号。Integer不必也不允许声明符号，其中存储的二进制数本身就代表有符号数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wire [signed] [[msb:lsb]] net1;</span><br></pre></td></tr></table></figure><p>msb&#x2F;lsb:最高&#x2F;最低有效位</p><h3 id="有符号数和无符号数"><a href="#有符号数和无符号数" class="headerlink" title="有符号数和无符号数"></a>有符号数和无符号数</h3><p>可以使用 $signed 和 ￥unsigned系统函数控制操作数的符号行为。</p><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p><strong>只有右操作表达式中含有无符号数，就按照无符号数的方式运算！</strong></p><h3 id="不同位宽数据计算"><a href="#不同位宽数据计算" class="headerlink" title="不同位宽数据计算"></a>不同位宽数据计算</h3><h4 id="长位宽赋值给短位宽"><a href="#长位宽赋值给短位宽" class="headerlink" title="长位宽赋值给短位宽"></a>长位宽赋值给短位宽</h4><p>直接截断高位</p><h4 id="短位宽赋值给长位宽"><a href="#短位宽赋值给长位宽" class="headerlink" title="短位宽赋值给长位宽"></a>短位宽赋值给长位宽</h4><p>需要对高位进行位扩展，具体是扩展1还是扩展0，记住：<strong>完全依据右操作数!</strong></p><p>1）右操作数是无符号数，则无论左操作数是什么类型，高位都扩展成0；</p><p>2）右操作数是有符号数，则要看右操作数的符号位，按照右操作数的符号位扩展，符号位是1就扩展1，是0就扩展0；</p><p><strong>只有右操作表达式中含有无符号数，就按照无符号数的方式运算！</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wire [31:0] y1 = imm26[15:0];</span><br><span class="line">wire [31:0] y2 = $signed(imm26[15:0]);</span><br></pre></td></tr></table></figure><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081435672.png" alt="image-20221123003953448" style="zoom:200%;" /><p>y1为零拓展，y2为符号拓展。</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><p>双目包括乘（*）、除（&#x2F;）、加（+）、减（-）、求幂（**）、取模（%）。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The forllowing are the arithmetic operators as defined by the Verilog language.</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//    + .... Addition</span></span><br><span class="line"><span class="comment">//    - .... Subtraction</span></span><br><span class="line"><span class="comment">//    * .... Multiplication</span></span><br><span class="line"><span class="comment">//    / .... Divide</span></span><br><span class="line"><span class="comment">//    % .... Modulus</span></span><br><span class="line"><span class="comment">//    ** ... Power Operator (i.e. 2**8 returns 256)</span></span><br></pre></td></tr></table></figure><ol><li><p>如果操作数某一位为 X，则计算结果也会全部出现 X。</p></li><li><p>对变量进行声明时，要根据变量的操作符对变量的位宽进行合理声明，不要让结果溢出。上述例子中，相加的 2 个变量位宽为 4bit，那么结果寄存器变量位宽最少为 5bit。<strong>否则，高位将被截断，导致结果高位丢失。</strong>乘除法同理，无符号数乘法时，结果变量位宽应该为 2 个操作数位宽之和。</p></li></ol><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] a,b;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">63</span>:<span class="number">0</span>] x = a*b;</span><br><span class="line"><span class="comment">/****或****/</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] hi,lo,a,b;</span><br><span class="line"><span class="keyword">assign</span> &#123;hi,lo&#125; = a*b;</span><br></pre></td></tr></table></figure><ol start="3"><li>溢出的判断</li></ol><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] AluRes;</span><br><span class="line"><span class="keyword">reg</span> Ov;</span><br><span class="line"><span class="comment">//in always</span></span><br><span class="line">&#123;msb, AluRes&#125; = &#123;A[<span class="number">31</span>], A&#125; + &#123;B[<span class="number">31</span>], B&#125;;</span><br><span class="line">Ov = (msb != AluRes[<span class="number">31</span>]);</span><br></pre></td></tr></table></figure><h4 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h4><h5 id="Verilog"><a href="#Verilog" class="headerlink" title="Verilog"></a>Verilog</h5><p>移位操作符包括左移（&lt;&lt;），右移（&gt;&gt;），算术左移（&lt;&lt;&lt;），算术右移（&gt;&gt;&gt;）。</p><p>移位操作符是双目操作符，两个操作数分别表示要进行移位的向量信号（操作符左侧）与移动的位数（操作符右侧）。</p><p>左移不区分逻辑和算术，都是右边低位会补 0。</p><p>右移区分逻辑和算术。<strong>逻辑右移时，左边高位会补 0；而算术右移时，左边高位会补充符号位，</strong>以保证数据缩小后值的正确性。</p><p>移位表达式（形如<code>i &gt;&gt;&gt; j</code>）的符号<strong>只</strong>由<code>i</code>的符号决定，<code>j</code>恒视作无符号且不参与该表达式的符号确定。</p><h5 id="补充：java"><a href="#补充：java" class="headerlink" title="补充：java"></a>补充：java</h5><p>因为mars的拓展指令需求class文件，所以需要搞清java与verilog的区别。</p><p>刚好与verilog相反，有符号右移为&gt;&gt;.无符号右移为&gt;&gt;&gt;。</p><p>因为java默认有符号数，verilog每个reg&#x2F;wire默认无符号数。</p><h4 id="位运算符-x2F-缩减运算符"><a href="#位运算符-x2F-缩减运算符" class="headerlink" title="位运算符&#x2F;缩减运算符"></a>位运算符&#x2F;缩减运算符</h4><p>同一组符号的运算符重载。做缩减运算符单目，做位运算符双目。</p><table><thead><tr><th>Operator</th><th>Description</th></tr></thead><tbody><tr><td>&amp;</td><td>and与</td></tr><tr><td>~&amp;</td><td>nand与非</td></tr><tr><td>|</td><td>or或</td></tr><tr><td>~|</td><td>nor或非</td></tr><tr><td>^</td><td>xor异或</td></tr><tr><td>^~ or ~^</td><td>xnor异或非</td></tr></tbody></table><p><strong>单目</strong>：将一个操作数的各个位进行运算。（（第一位op第二位）op第三位）·······</p><p>^:常用来计算一个数据中1的个数是奇数还是偶数，是奇数异或结果为1，是偶数异或结果为0。</p><p>（^data[9:0]) &#x3D;&#x3D; 1） iff data 9:0中1的个数是奇数 </p><p><strong>双目</strong>：将两个操作数的相应位进行与或等运算</p><p>不同长度的数据进行位运算，系统自动按右端对齐，位数少的高位补0，然后进行位运算</p><h4 id="等式运算符"><a href="#等式运算符" class="headerlink" title="等式运算符"></a>等式运算符</h4><h5 id="逻辑等式-x3D-x3D-x2F-x3D"><a href="#逻辑等式-x3D-x3D-x2F-x3D" class="headerlink" title="逻辑等式 &#x3D;&#x3D; &#x2F; !&#x3D;"></a>逻辑等式 &#x3D;&#x3D; &#x2F; !&#x3D;</h5><p>操作数中某些位是不定值和高阻态时结果可能为不定值x。其余同</p><h5 id="case等式-x3D-x3D-x3D-x2F-x3D-x3D"><a href="#case等式-x3D-x3D-x3D-x2F-x3D-x3D" class="headerlink" title="case等式 &#x3D;&#x3D;&#x3D;  &#x2F; ! &#x3D;&#x3D;"></a>case等式 &#x3D;&#x3D;&#x3D;  &#x2F; ! &#x3D;&#x3D;</h5><p>操作数中某些位是不定值和高阻态时也会进行比较，x&#x3D;x，z&#x3D;z输出1。其余同。主要用于某些情况下线路不定值和</p><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>&amp;&amp;和||和 ！</p><p>!：逻辑非，对一个数作用。</p><p>~：按位取反。</p><h4 id="位拼接运算"><a href="#位拼接运算" class="headerlink" title="位拼接运算"></a>位拼接运算</h4><ol><li>一个完整的拼接信号对应一个大括号。</li><li><strong>信号位宽必须明确，包括常量。</strong> （常被忽略，写成 {a,b,0},实际上应为{a,b,1’b0) )</li></ol><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;信号<span class="number">1</span>的某几位,信号<span class="number">2</span>的某几位......&#125;</span><br><span class="line">&#123;a,b[<span class="number">3</span>:<span class="number">0</span>],w,<span class="number">3&#x27;b101</span>&#125;</span><br><span class="line">&#123;<span class="number">4</span>&#123;w&#125;&#125;</span><br><span class="line">&#123;b,&#123;<span class="number">3</span>&#123;a,b&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h4><p>三目表达式<code>i ? j : k</code>中的<code>i</code>不参与该表达式的符号确定。</p><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><h4 id="wire连续赋值"><a href="#wire连续赋值" class="headerlink" title="wire连续赋值"></a>wire连续赋值</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wire      Cout, A, B ;</span><br><span class="line">assign    Cout  = A &amp; B ;     //实现计算A与B的功能</span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wire      A, B ;</span><br><span class="line">wire      Cout = A &amp; B ;</span><br></pre></td></tr></table></figure><p>在 wire 型变量声明的时候同时对其赋值。wire 型变量只能被赋值一次，因此该种连续赋值方式也只能有一次。不可再对Cout进行assign赋值。</p><p>个人认同并建议使用第二种写法，可以的话则将声明与赋值写于一起，简洁。但是仍需要注意，声明在使用前，不可在代码中先使用再声明。</p><h4 id="always块"><a href="#always块" class="headerlink" title="always块"></a>always块</h4><p>always块里赋值对象不能是wire型，只能是reg型</p><p>如果一个module的某个输出端口需要在always块中赋值：</p><ol><li>很多代码的做法是将该信号定义为wire类型，而同时在程序中再定义一个对应的reg型变量，在always模块中对后面这个定义的reg型变量赋值，而使用assign将reg型变量的值赋给输出端口。</li><li>将输出端口定义为reg型</li></ol><h4 id="阻塞非阻塞赋值"><a href="#阻塞非阻塞赋值" class="headerlink" title="阻塞非阻塞赋值"></a>阻塞非阻塞赋值</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">`timescale 1ns/1ns</span><br><span class="line"> </span><br><span class="line">module test ;</span><br><span class="line">    reg [3:0]   ai, bi ;</span><br><span class="line">    reg [3:0]   ai2, bi2 ;</span><br><span class="line">    reg [3:0]   value_blk ;</span><br><span class="line">    reg [3:0]   value_non ;</span><br><span class="line">    reg [3:0]   value_non2 ;</span><br><span class="line"> </span><br><span class="line">    initial begin</span><br><span class="line">        ai            = 4&#x27;d1 ;   //(1)</span><br><span class="line">        bi            = 4&#x27;d2 ;   //(2)</span><br><span class="line">        ai2           = 4&#x27;d7 ;   //(3)</span><br><span class="line">        bi2           = 4&#x27;d8 ;   //(4)</span><br><span class="line">        #20 ;                    //(5)</span><br><span class="line"> </span><br><span class="line">        //non-block-assigment with block-assignment</span><br><span class="line">        ai            = 4&#x27;d3 ;     //(6)</span><br><span class="line">        bi            = 4&#x27;d4 ;     //(7)</span><br><span class="line">        value_blk     = ai + bi ;  //(8)</span><br><span class="line">        value_non     &lt;= ai + bi ; //(9)</span><br><span class="line"> </span><br><span class="line">        //non-block-assigment itself</span><br><span class="line">        ai2           &lt;= 4&#x27;d5 ;           //(10)</span><br><span class="line">        bi2           &lt;= 4&#x27;d6 ;           //(11)</span><br><span class="line">        value_non2    &lt;= ai2 + bi2 ;      //(12)</span><br><span class="line">    end</span><br><span class="line"> </span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><p>程序只在某一个块中执行阻塞非阻塞。</p><p>语句（1）-（8）都是阻塞赋值，按照顺序执行。</p><p>进行（1）-（5）时，（8）为 X.</p><p>然后同一时序，逐步执行（6）（7），再执行（8）(使用前两步的值)。</p><p>然后执行并发块，（9）和（12）都使用并发块之前得出的值，而不使用并发块中得到的值。</p><h3 id="表达式中的符号性"><a href="#表达式中的符号性" class="headerlink" title="表达式中的符号性"></a>表达式中的符号性</h3><p>问题简介：在长的表达式中（一般为三目），若不管表达式的符号性，会导致原本期望有符号数的结果转化为无符号数的结果。</p><p>传递过程：先确定表达式整体的符号性，再将此符号性传递给所有子表达式，<strong>（自决定的子表达式不受影响）</strong>。类似递归的过程，遇到原子表达式则强制转换原子表达式的符号。</p><p>表达式符号确定原则：子表达式中任意一个被确定为无符号，那么整个表达式都被确定为无符号，否则有符号.</p><p>子表达式符号确定：</p><p>常量未声明进制默认十进制，一律被认为是有符号数。声明进制不声明符号则为无符号数。</p><p>某些运算符的符号性仅由其中部分操作数确定：移位运算符、三目运算符</p><p>例（BUAACO教程)：</p><blockquote><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> ? <span class="built_in">$signed</span>(a)&gt;&gt;&gt;b : <span class="number">4&#x27;b0</span></span><br></pre></td></tr></table></figure></blockquote><p><code>符号确定</code>：首先<code>1</code>不参与符号确定，排除；<code>$signed(a)&gt;&gt;&gt;b</code>和<code>4&#39;b0</code>，其中<code>4&#39;b0</code>显然无符号，<code>$signed(a)&gt;&gt;&gt;b</code>符号由<code>$signed(a)</code>决定，是有符号的；则表达式<code>1 ? 有符号 : 无符号</code>，由符号性传递，表达式整体无符号。</p><p><code>向内传播</code>：首先<code>1</code>不受影响，排除；原子表达式<code>4&#39;b0</code>本就是无符号，无需转换；<code>$signed(a)&gt;&gt;&gt;b</code>中<code>b</code>不受影响，再次递归进入<code>$signed(a)</code>，是有符号原子表达式，强制转化成无符号，即<code>$unsigned($signed(a))</code>。</p><p>最终表达式等价<code>a &gt;&gt; b</code>，相当于仍对<code>a</code>进行逻辑右移。</p><h4 id="写代码的解决方法"><a href="#写代码的解决方法" class="headerlink" title="写代码的解决方法"></a>写代码的解决方法</h4><ol><li>分离变量法</li></ol><p>声明变量可以防止向内传播。</p><pre><code>wire [31:0]lshift;      //逻辑移位wire [31:0]ashift;      //算术移位assign lshift = $signed(A)&gt;&gt;B;assign ashift = $signed(A)&gt;&gt;&gt;B;assign C = (ALUOp==3&#39;b000)? A+B:            (ALUOp==3&#39;b001)? A-B:            (ALUOp==3&#39;b010)? A&amp;B:            (ALUOp==3&#39;b011)? A|B:            (ALUOp==3&#39;b100)? lshift:            (ALUOp==3&#39;b101)? ashift:            (ALUOp==3&#39;b110)? ((A&gt;B)?1:0):            (ALUOp==3&#39;b111)? (($signed(A)&gt;$signed(B))?1:0):            0;</code></pre><ol start="2"><li>$signed隔断</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">assign C = (ALUOp==3&#x27;b000)? A+B:</span><br><span class="line">            (ALUOp==3&#x27;b001)? A-B:</span><br><span class="line">            (ALUOp==3&#x27;b010)? A&amp;B:</span><br><span class="line">            (ALUOp==3&#x27;b011)? A|B:</span><br><span class="line">            (ALUOp==3&#x27;b100)? lshift:</span><br><span class="line">            (ALUOp==3&#x27;b101)? $signed($signed(A)&gt;&gt;&gt;B):</span><br><span class="line">            (ALUOp==3&#x27;b110)? ((A&gt;B)?1:0):</span><br><span class="line">            (ALUOp==3&#x27;b111)? (($signed(A)&gt;$signed(B))?1:0):</span><br><span class="line">            0;</span><br></pre></td></tr></table></figure><h3 id="函数用法"><a href="#函数用法" class="headerlink" title="函数用法"></a>函数用法</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> &lt;返回值的类型或范围&gt;(函数名);</span><br><span class="line">    &lt;端口说明语句&gt;          <span class="comment">// input XXX</span></span><br><span class="line">    &lt;变量类型说明语句&gt;      <span class="comment">// reg YYY</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        &lt;语句&gt;</span><br><span class="line">        ......</span><br><span class="line">        函数名 = ZZZ;       <span class="comment">// 函数名就相当于输出变量;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure><p>函数的目的是返回一个用于表达式的值。</p><p>函数的定义不能包含任何的时间控制语句。它是个时序逻辑。</p><p>定义函数时必须要有一个输入参量</p><p>函数的结果值应存放在与函数名同名的内部变量中且必须赋值。</p><p>例</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#定义</span><br><span class="line"><span class="keyword">function</span>[<span class="number">31</span>:<span class="number">0</span>]factorial #返回值:[<span class="number">31</span>:<span class="number">0</span>]寄存器（默认）</span><br><span class="line">    <span class="keyword">input</span>[<span class="number">3</span>:<span class="number">0</span>]in_data;#函数输入参数</span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>]index;#函数内部用寄存器</span><br><span class="line">    <span class="keyword">begin</span>#开始定义</span><br><span class="line">        factorial=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(index=<span class="number">2</span>;index&lt;=in_data;index=index+<span class="number">1</span>)</span><br><span class="line">            factorial=index*factorial;</span><br><span class="line">    <span class="keyword">end</span>#结束定义</span><br><span class="line"><span class="keyword">endfunction</span>#结束函数</span><br><span class="line"></span><br><span class="line">#使用</span><br><span class="line">result = factorial(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h3 id="for循环用法"><a href="#for循环用法" class="headerlink" title="for循环用法"></a>for循环用法</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> i;<span class="comment">//注意integer申明在always外面</span></span><br><span class="line"><span class="keyword">always</span>@(*)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX; i = i + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// do what u want</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>for循环一般在组合逻辑中作为一种函数出现，和always(*)相伴，如果不放在always块中，而是直接出现，<br>会报错。</li><li>for循环一般用于计数，而计数时，会有中间变量，那么每次启动for循环用于计数时，要保证中间变量被清零了。</li></ol><p>例：附上一个正常的计数代码段，功能是判断RegRead1这个wire里“1”的个数是不是奇数：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> odd;   <span class="comment">// is odd??</span></span><br><span class="line"><span class="keyword">reg</span>[<span class="number">31</span>:<span class="number">0</span>] num;   <span class="comment">// how many &quot;1&quot; in RegRead1??</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">integer</span> i;</span><br><span class="line"><span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">    num = <span class="number">0</span>;    </span><br><span class="line">    <span class="comment">// loop start, intermediate variable set to 0</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i = i + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(RegRead1[i] == <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">            num = num + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">assign</span> odd = num[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h1 id="TestBench"><a href="#TestBench" class="headerlink" title="TestBench"></a>TestBench</h1><p>本质也是个.v文件。调用要测试的模块喂数据出波形图。</p><h2 id="finish"><a href="#finish" class="headerlink" title="$finish"></a>$finish</h2><p>在initial末尾（end前）加上<code>$finish;</code>可有效减少模拟时间。</p><h2 id="时钟周期"><a href="#时钟周期" class="headerlink" title="时钟周期"></a>时钟周期</h2><p>创建一个周期为10单位的时钟</p><p>&#96;timescale 1ns &#x2F; 1ps 一单位时间为1ns。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span> </span><br><span class="line">   <span class="keyword">begin</span></span><br><span class="line">        clk = <span class="number">0</span>;</span><br><span class="line">        ......</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">......</span><br><span class="line"><span class="keyword">always</span> #<span class="number">5</span> clk = ~clk</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> BUAA课程学习 </category>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA_CO </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* ҳ����ͷͼ͸�� */#footer {    background: transparent !important;}#page-header {    background: transparent !important;}/* ����ģʽ����͸�� */#footer::before {    background: transparent !important;}#page-header::before {    background: transparent !important;}/* ҹ��ģʽ����͸�� */[data-theme="dark"] #footer::before {    background: transparent !important;}[data-theme="dark"] #page-header::before {    background: transparent !important;}/* �����������Ϣ��Ƭ��̬����ɫ */#aside-content>.card-widget.card-info {    background: linear-gradient(-45deg,            #e8d8b9,            #eccec5,            #a3e9eb,            #bdbdf0,            #eec1ea);    box-shadow: 0 0 5px rgb(66, 68, 68);    position: relative;    background-size: 400% 400%;    -webkit-animation: Gradient 10s ease infinite;    -moz-animation: Gradient 10s ease infinite;    animation: Gradient 10s ease infinite !important;}@-webkit-keyframes Gradient {    0% {        background-position: 0% 50%;    }    50% {        background-position: 100% 50%;    }    100% {        background-position: 0% 50%;    }}@-moz-keyframes Gradient {    0% {        background-position: 0% 50%;    }    50% {        background-position: 100% 50%;    }    100% {        background-position: 0% 50%;    }}@keyframes Gradient {    0% {        background-position: 0% 50%;    }    50% {        background-position: 100% 50%;    }    100% {        background-position: 0% 50%;    }}/* ��ҹģʽ���� */[data-theme="dark"] #aside-content>.card-widget.card-info {    background: #191919ee;}/* ������ϢFollow me��ť */#aside-content>.card-widget.card-info>#card-info-btn {    background-color: #3eb8be;    border-radius: 8px;}]]></content>
      
    </entry>
    
    
  
</search>

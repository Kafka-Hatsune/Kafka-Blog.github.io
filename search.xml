<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MIPS基础</title>
      <link href="/2023/01/12/%E8%AE%A1%E7%BB%84/MIPS%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/01/12/%E8%AE%A1%E7%BB%84/MIPS%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="MIPS笔记"><a href="#MIPS笔记" class="headerlink" title="MIPS笔记"></a>MIPS笔记</h1><h2 id="翻译注意-x2F-C代码注意"><a href="#翻译注意-x2F-C代码注意" class="headerlink" title="翻译注意&#x2F;C代码注意"></a>翻译注意&#x2F;C代码注意</h2><h3 id="函数内联"><a href="#函数内联" class="headerlink" title="函数内联"></a>函数内联</h3><p>能在main里面写的函数就在main里面写，避免压栈、弹栈之类的指令损耗</p><h3 id="避免null类型多条件判断"><a href="#避免null类型多条件判断" class="headerlink" title="避免null类型多条件判断"></a>避免null类型多条件判断</h3><p>在写if对于指针的处理时，我们把是否等于null放在if第一个条件判断，因为C中第一个条件不满足之后的条件不再进行运算判断。</p><p>MIPS若将多条件判断写成多个slt形式再and，显然不是C的机制，很有可能因为数组越界之类报错。</p><h2 id="指令注意"><a href="#指令注意" class="headerlink" title="指令注意"></a>指令注意</h2><h3 id="读存储器"><a href="#读存储器" class="headerlink" title="读存储器"></a>读存储器</h3><h4 id="lb-amp-lbu"><a href="#lb-amp-lbu" class="headerlink" title="lb &amp; lbu"></a>lb &amp; lbu</h4><p>读字节：对应C语言中的char型变量</p><p>其中lbu将被写入寄存器高24位都填充为0</p><p>lb:从内存中取出一字节（8位）数据加载到寄存器（32位）</p><p>从内存低位取，加载到寄存器低位，其余高位进行符号拓展</p><p>例：</p><table><thead><tr><th>S0</th><th><strong>X</strong></th><th><strong>X</strong></th><th><strong>X</strong></th><th><strong>X</strong></th></tr></thead><tbody><tr><td><strong>S1</strong></td><td><strong>00</strong></td><td><strong>00</strong></td><td><strong>00</strong></td><td><strong>01</strong></td></tr><tr><td><strong>S2</strong></td><td><strong>FF</strong></td><td><strong>FF</strong></td><td><strong>FF</strong></td><td><strong>FF</strong></td></tr></tbody></table><table><thead><tr><th>B3</th><th>B2</th><th>B1</th><th>B0</th></tr></thead><tbody><tr><td>00</td><td>80</td><td>01</td><td>80</td></tr></tbody></table><p>lb $s1,1($s0)# $s1 &#x3D; 0x00000001</p><p>lb $s2,0($s0)# $s2 &#x3D; 0xffffff80</p><h4 id="lh-amp-lhu"><a href="#lh-amp-lhu" class="headerlink" title="lh &amp; lhu"></a>lh &amp; lhu</h4><p>读半字：对应short型</p><h4 id="lw"><a href="#lw" class="headerlink" title="lw"></a>lw</h4><p>读字：对应int型</p><p>没有lwu指令，因为主存中读出和寄存器需要写入的宽度都是32位，不存在符号拓展的需求。</p><h3 id="写寄存器"><a href="#写寄存器" class="headerlink" title="写寄存器"></a>写寄存器</h3><h4 id="li"><a href="#li" class="headerlink" title="li"></a>li</h4><p>写一个立即数</p><h4 id="la"><a href="#la" class="headerlink" title="la"></a>la</h4><p>写一个标签地址，常用来加载字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">str: .asciiz    <span class="string">&quot;Hello World&quot;</span></span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">la  $a0, str</span><br><span class="line">li  $v0, <span class="number">4</span></span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><h4 id="lui"><a href="#lui" class="headerlink" title="lui"></a>lui</h4><p>寄存器加载立即数高位：</p><p><code>Lui rt immediate</code> 将指令的16位立即数复制到tr寄存器的高16位</p><p>往往和ori搭配使用，实现向寄存器中加载一个32位数。目的：构造负数</p><p>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lui $a2, 123            # 符号位为 0</span><br><span class="line">lui $a3, 0xffff         # 符号位为 1</span><br><span class="line">ori $a3, $a3, 0xffff    # $a3 = -1</span><br></pre></td></tr></table></figure><h3 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h3><h4 id="加减"><a href="#加减" class="headerlink" title="加减"></a>加减</h4><p>add和addu的区别在于前者在溢出后会发生异常，而后者忽略溢出</p><h4 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h4><p>mfhi $t0 读hi寄存器(move from hi)</p><p>mflo $t0 读lo寄存器(move from low)</p><p>mult符号乘</p><p>对于乘法，hi保存乘积的高32位，lo保存乘积的低32位；</p><h4 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h4><p>div符号除 rs, rt (rs&#x2F;rt)</p><p>对于除法，<strong>hi保存余数，lo保存商。</strong></p><p>因此判断是否整除即可判断lo寄存器中是否值为0。</p><p>tips:记忆</p><p><strong>重要的&#x2F;常用的结果都在low寄存器里，比如乘法中的低位结果（一般认为不会超过32位），除法中的商。</strong></p><h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><h4 id="或非nor"><a href="#或非nor" class="headerlink" title="或非nor"></a>或非nor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nor $t0, $s0, $<span class="number">0</span> <span class="comment">//与0做或非运算等于取反，t0=~s0</span></span><br></pre></td></tr></table></figure><h2 id="寄存器使用"><a href="#寄存器使用" class="headerlink" title="寄存器使用"></a>寄存器使用</h2><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301121748378.png" alt="image-20221014154732465"></p><h3 id="26-27：-k0-k1"><a href="#26-27：-k0-k1" class="headerlink" title="$26 - $27：($k0,$k1)"></a>$26 - $27：($k0,$k1)</h3><p>为操作系统／异常处理保留，至少要预留一个。异常（或中断）是一种不需要在程序中显示调用的过程。MIPS有个叫异常程序计数器（exception program counter,EPC)的寄存器，属于CP0寄存器，用于保存造成异常的那条指令的地址。查看控制寄存器的唯一方法是把它复制到通用寄存器里，指令mfc0(move from system control)可以将EPC中的地址复制到某个通用寄存器中，通过跳转语句（jr)，程序可以返回到造成异常的那条指令处继续执行。MIPS程序员都必须保留两个寄存器$k0和$k1，供操作系统使用。</p><p>发生异常时，这两个寄存器的值不会被恢复，编译器也不使用k0和k1,异常处理函数可以将返回地址放到这两个中的任何一个，然后使用jr跳转到造成异常的指令处继续执行。</p><h3 id="28：-gp"><a href="#28：-gp" class="headerlink" title="$28：($gp)"></a>$28：($gp)</h3><p>为了简化静态数据的访问，MIPS软件保留了一个寄存器：全局指针gp(global pointer,$gp)，全局指针只想静态数据区中的运行时决定的地址，在存取位于gp值上下32KB范围内的数据时，只需要一条以gp为基指针的指令即可。在编译时，数据须在以gp为基指针的64KB范围内。</p><h3 id="29：-sp"><a href="#29：-sp" class="headerlink" title="$29：($sp)"></a>$29：($sp)</h3><p>sp(stack pointer) 用于指向堆栈。</p><h3 id="30：-fp"><a href="#30：-fp" class="headerlink" title="$30：($fp)"></a>$30：($fp)</h3><p>考虑进程执行时发生函数调用的场景，母函数和子函数使用的是同一个栈，在通常的情况下，我们并不需要区分母函数和子函数分别使用了栈的哪个部分。但是，当我们需要在执行过程中对函数调用进行backtrace的时候，这一信息就很重要了。</p><p>简单的说，stack frame就是一个函数所使用的stack的一部分，所有函数的stack frame串起来就组成了一个完整的栈。stack frame的两个边界分别由FP和SP来限定。</p><ul><li>fp(frame pointer) 用作帧指针。帧指针充当被调用函数和调用函数之间的锚。</li><li>当调用一个函数时，该函数首先将 fp 的当前值保存在堆栈上。然后，它将 sp 寄存器的值保存在 fp 寄存器中。然后递减 sp 寄存器来为本地变量分配空间。</li><li>fp 寄存器用于访问本地变量和参数，局部变量位于帧指针的负偏移量处，传递给函数的参数位于帧指针的正偏移量。</li><li>当函数返回时， fp 寄存器被复制到 sp 寄存器中，这将释放用于局部变量的堆栈，函数调用者的 fp 寄存器的值由pop从堆栈中恢复。</li></ul><h2 id="常用宏"><a href="#常用宏" class="headerlink" title="常用宏"></a>常用宏</h2><h4 id="终止程序"><a href="#终止程序" class="headerlink" title="终止程序"></a>终止程序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.macro end</span><br><span class="line">    li      $v0, <span class="number">10</span></span><br><span class="line">    syscall</span><br><span class="line">.end_macro</span><br></pre></td></tr></table></figure><h4 id="输入-x2F-输出"><a href="#输入-x2F-输出" class="headerlink" title="输入&#x2F;输出"></a>输入&#x2F;输出</h4><p>输入流</p><p>  <strong>li$v0, x</strong></p><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301121740563.png" alt="image-20221018101818451"></p><p><img src="C:\Users\Kafka\Desktop\Typora\计组笔记\MIPS笔记.assets\image-20221018101833202.png" alt="image-20221018101833202"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.macro <span class="title function_">getInt</span><span class="params">(%des)</span></span><br><span class="line">    li      $v0, <span class="number">5</span></span><br><span class="line">    syscall</span><br><span class="line">    move    %des, $v0</span><br><span class="line">.end_macro</span><br></pre></td></tr></table></figure><p>输出流</p><p>$a0存储要输出的东西，$v0实现系统调用</p><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301121740574.png" alt="image-20221018102006940"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.macro <span class="title function_">printInt</span><span class="params">(%src)</span></span><br><span class="line">    move    $a0, %src</span><br><span class="line">    li      $v0, <span class="number">1</span></span><br><span class="line">    syscall</span><br><span class="line">.end_macro</span><br></pre></td></tr></table></figure><h5 id="打印简单的字符"><a href="#打印简单的字符" class="headerlink" title="打印简单的字符"></a>打印简单的字符</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.macro printspace</span><br><span class="line">    la    $a0, strspace </span><br><span class="line">    li      $v0, <span class="number">4</span></span><br><span class="line">    syscall</span><br><span class="line">.end_macro</span><br><span class="line">.macro printendl</span><br><span class="line">    la    $a0, strendl</span><br><span class="line">    li      $v0, <span class="number">4</span></span><br><span class="line">    syscall</span><br><span class="line">.end_macro</span><br><span class="line">    </span><br><span class="line">.text</span><br><span class="line">strspace: .asciiz <span class="string">&quot; &quot;</span></span><br><span class="line">strendl: .asciiz <span class="string">&quot;\n&quot;</span></span><br></pre></td></tr></table></figure><h4 id="栈相关"><a href="#栈相关" class="headerlink" title="栈相关"></a>栈相关</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.macro <span class="title function_">push</span><span class="params">(%src)</span></span><br><span class="line">    sw      %src, <span class="number">0</span>($sp)</span><br><span class="line">    subi    $sp, $sp, <span class="number">4</span></span><br><span class="line">.end_macro</span><br><span class="line"></span><br><span class="line">.macro <span class="title function_">pop</span><span class="params">(%des)</span></span><br><span class="line">    addi    $sp, $sp, <span class="number">4</span></span><br><span class="line">    lw      %des, <span class="number">0</span>($sp) </span><br><span class="line">.end_macro</span><br></pre></td></tr></table></figure><p>由于栈向下增长的特性，栈指针指向一个可以存储数据的起始点。读数据是</p><p>push 先存再subi（stack[sp–]&#x3D;data)</p><p>pop 先addi再读(data&#x3D;stack[++sp])</p><h4 id="获取数组偏移值"><a href="#获取数组偏移值" class="headerlink" title="获取数组偏移值"></a>获取数组偏移值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">二维</span><br><span class="line"># <span class="keyword">for</span> matrix[<span class="number">8</span>][<span class="number">8</span>],offset_ans = <span class="number">4</span>*( 8i + j)</span><br><span class="line"># <span class="keyword">for</span> matrix[<span class="number">8</span>][x],offset_ans = <span class="number">4</span>*( x*i + j)</span><br><span class="line">.macro <span class="title function_">getMatrixIndex</span><span class="params">(%ans,%i,%j)</span></span><br><span class="line">sll %ans, %i, <span class="number">3</span></span><br><span class="line">add %ans, %ans, %j</span><br><span class="line">sll %ans, %ans, <span class="number">2</span></span><br><span class="line">.end_macro</span><br><span class="line">一维</span><br><span class="line"># <span class="keyword">for</span> array[<span class="number">8</span>],offset_ans = <span class="number">4</span>*i</span><br><span class="line">.macro <span class="title function_">getArrayIndex</span><span class="params">(%ans,%i)</span></span><br><span class="line">sll %ans, %i, <span class="number">2</span></span><br><span class="line">.end_macro</span><br></pre></td></tr></table></figure><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><table><thead><tr><th>关键字</th><th>用途</th><th>对应C变量</th></tr></thead><tbody><tr><td>.byte</td><td>声明8位变量</td><td>char/unsigned char</td></tr><tr><td>.half</td><td>声明16位变量</td><td>short/unsigned short</td></tr><tr><td>.word</td><td>声明32位变量</td><td>int/unsigned int</td></tr><tr><td>.ascii</td><td>声明字符串，末尾没有‘\0’</td><td></td></tr><tr><td>.asciiz</td><td>声明字符串，末尾有‘\0’</td><td></td></tr><tr><td>.space</td><td>为变量预留指定的<strong>字节</strong>数（一般取4的整数倍）</td><td>string（数组）</td></tr></tbody></table><h3 id="声明-x2F-操作数组"><a href="#声明-x2F-操作数组" class="headerlink" title="声明&#x2F;操作数组"></a>声明&#x2F;操作数组</h3><p>操作数组的行为随着元素的大小有不同。举例：</p><p>int数组：一个元素4字节，常用操作lw读元素,sw写元素，偏移量为元素个数*4</p><p>char数组：一个元素1字节，常用操作lbu读元素，sb写元素，偏移量为元素个数*1</p><h5 id="声明-1"><a href="#声明-1" class="headerlink" title="声明"></a>声明</h5><p>在.data区域声明</p><p>数组名： .space 大小（以字节为单位），注意规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matrix: .space <span class="number">256</span></span><br></pre></td></tr></table></figure><p>在申请空间时尽可能申 4 的倍数大小，防止在数据存取过程中出现问题。</p><h5 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h5><p>操作格式</p><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301121740576.png" alt="image-20221217201947713"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">op reg, offset(base)</span><br></pre></td></tr></table></figure><p><em><code>base</code>只能是寄存器，<code>offset</code>只能是标签或立即数。</em></p><p>现在比较多的使用方法</p><p><code>0($sp)</code> </p><p><code> Array(offset)</code>（Array:数组标签，offset:寄存器)</p><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">myArray1: .word 100:3 # 初始化了长度为3的数组，且数组中每一个元素都是100</span><br><span class="line">myArray2: .word 1,2,3,4,5,6 # 当然也可以全部初始化</span><br></pre></td></tr></table></figure><h3 id="声明字符串"><a href="#声明字符串" class="headerlink" title="声明字符串"></a>声明字符串</h3><p>单个char类型强烈建议用ascii码数值表示。变量字符串用字符数组表示，常量字符串才用此方法声明</p><h5 id="声明-2"><a href="#声明-2" class="headerlink" title="声明"></a>声明</h5><p>在.data区域声明</p><p>字符串名： .asciiz “字符串”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str: .asciiz    <span class="string">&quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure><p><code>.ascii</code>不会在字符串后加上<code>&#39;\0&#39;</code>，而<code>.asciiz</code>会在字符串加<code>&#39;\0&#39;</code>。两者均以字节为单位存储数据，这会对我们带来一些小麻烦，<code>.asciiz</code>之后分配的空间首地址有可能无法字对齐，因此我们在定义<code>.ascii</code>与<code>.asciiz</code>时尽量写在最后面。</p><h5 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">str: .asciiz    <span class="string">&quot;Hello World&quot;</span></span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">la  $a0, str</span><br><span class="line">li  $v0, <span class="number">4</span></span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>常用条件跳转语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">相等时跳转 beq $t0,$t1,labal</span><br><span class="line">不等时跳转 bne $t0,$t1,labal</span><br><span class="line">    </span><br><span class="line">大于<span class="number">0</span>时跳转 bgtz $t1,labal</span><br><span class="line">大于等于<span class="number">0</span>时跳转 bgez $t1,labal</span><br><span class="line">小于<span class="number">0</span>时跳转 bltz $t1,labal</span><br><span class="line">小于等于<span class="number">0</span>时跳转 blez $t1,labal </span><br><span class="line"></span><br><span class="line">小于时置<span class="number">0</span> slt dst,src1,src2(搭配beq,bne)</span><br><span class="line">小于立即数置<span class="number">1</span> slti dst,src,immediate</span><br></pre></td></tr></table></figure><p>一个条件判断中的多重判断和复杂比较条件的判断需使用中间判断量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//(a[ni][nj - 1] == 0 &amp;&amp; visit[ni][nj - 1] == 0)</span></span><br><span class="line"><span class="built_in">getIndex</span>($t3, $t2, $t1) #t3 = index</span><br><span class="line">lw $t5, <span class="built_in">a</span>($t3)</span><br><span class="line">seq $t5, $t5, <span class="number">0</span><span class="comment">//等于时置1</span></span><br><span class="line">lw $t6, <span class="built_in">visit</span>($t3)</span><br><span class="line">seq $t6, $t6, <span class="number">0</span></span><br><span class="line"><span class="keyword">and</span> $t4, $t5, $t6  </span><br><span class="line"><span class="comment">//ni - 1 &gt;= 0</span></span><br><span class="line">blt $t2, <span class="number">1</span>, if_2_end<span class="comment">//小于时置1</span></span><br><span class="line"><span class="comment">//ni + 1 &lt; n</span></span><br><span class="line">add $t2, $t0, <span class="number">1</span>#t2 = ni+<span class="number">1</span></span><br><span class="line">bge $t2, $s0, if_3_end  <span class="comment">//大于等于时置1 </span></span><br></pre></td></tr></table></figure><p>记得写j end</p><p>往往，if语句的第一个判断是基础判断，C语言中的&amp;&amp;语句在基础条件不成立时会自动跳出，而MIPS中，若先写置1情况再&amp;&amp;可能会产生溢出等错误，最好的写法是将每个判断独立，有一个等于0则直接跳到if_end。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C</span></span><br><span class="line">(condition1 &amp;&amp; condition2 &amp;&amp; ......)</span><br><span class="line"><span class="comment">//MIPS</span></span><br><span class="line"><span class="keyword">if</span>(condition1)&#123;</span><br><span class="line">    <span class="keyword">if</span>(condition2)&#123;</span><br><span class="line">        .......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>条件语句判断循环变量 i + 每次循环后addi i,i,1</p><h2 id="函数操作"><a href="#函数操作" class="headerlink" title="函数操作"></a>函数操作</h2><h3 id="形式化传参"><a href="#形式化传参" class="headerlink" title="形式化传参"></a>形式化传参</h3><p>认为$a0到$a3四个寄存器专门用来传递函数参数。</p><p>调用函数时，将要调用的函数参数传至<strong>$a0到$a3</strong>，在函数内部把$a0到$a3的值传到函数内部设置的寄存器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move dest source</span><br></pre></td></tr></table></figure><h3 id="返回值接收"><a href="#返回值接收" class="headerlink" title="返回值接收"></a>返回值接收</h3><p>用$v0,$v1接收函数返回值</p><h3 id="函数调用和返回形式"><a href="#函数调用和返回形式" class="headerlink" title="函数调用和返回形式"></a>函数调用和返回形式</h3><h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><p>使用jal调用函数</p><h4 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h4><p>使用jr $ra返回</p><h5 id="返回语句return"><a href="#返回语句return" class="headerlink" title="返回语句return"></a>返回语句return</h5><p>切记是跳转到pop_process过程，在经历此过程后再jr $ra</p><h5 id="有无返回值函数返回区别"><a href="#有无返回值函数返回区别" class="headerlink" title="有无返回值函数返回区别"></a>有无返回值函数返回区别</h5><p>如果函数返回值为void,则直接j pop_process</p><p>如果函数返回值为int,则将返回值保存至<strong>$v0-$v1</strong>,在main部分根据需要传递值,然后j pop_process</p><h3 id="被调用者保存函数内部寄存器"><a href="#被调用者保存函数内部寄存器" class="headerlink" title="被调用者保存函数内部寄存器"></a>被调用者保存函数内部寄存器</h3><h4 id="实现原理：栈"><a href="#实现原理：栈" class="headerlink" title="实现原理：栈"></a>实现原理：栈</h4><p>通过下图可知，当函数需要获取若干空间保存数据时，将栈指针（$sp）向低位地址调整从而获得相应空间（这一空间被称为栈帧）</p><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301121740584.png" alt="image-20221014154732465"></p><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>需要分配一组寄存器给函数内部使用。考虑到main主体的简洁性，选择被调用者保存方法。<strong>内部可使用的寄存器约定为$t0-$t7</strong>。</p><p>在函数开头将$t0-$t7入栈，在函数结尾将$t0-$t7出栈。</p><p>ps:图省事也可将$ra也顺便入栈出栈。</p><h3 id="递归函数和非递归函数区别"><a href="#递归函数和非递归函数区别" class="headerlink" title="递归函数和非递归函数区别"></a>递归函数和非递归函数区别</h3><p>递归函数必须要维护栈保存数据，非递归随意，为了一致性也可以维护。</p><h2 id="使用命令行进行导出"><a href="#使用命令行进行导出" class="headerlink" title="使用命令行进行导出"></a>使用命令行进行导出</h2><p>在导出代码和数据时，一般只能导出0x00003000-0x00003088和0x00000000-0x00000ffc这两段。对于其他部分，比如中断&#x2F;异常处理程序的导出，就需要使用命令行进行操作了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar #MARS 的文件路径# a db mc CompactDataAtZero dump <span class="number">0x00004180</span>-<span class="number">0x00004ffc</span>#需要导出的数据范围# HexText#十六进制# E:\exc.txt#<span class="number">16</span> 进制码输出文件路径# E:\eh.asm#源文件路径#</span><br></pre></td></tr></table></figure><p>java -jar</p><p>MARS 的文件路径</p><p>a db mc CompactDataAtZero dump（MARS内部命令行指令）</p><p>需要导出的数据范围</p><p>进制</p><p>进制码输出文件路径  源文件路径（依然满足dest source)</p><h2 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h2><p>换算举例：</p><p>1GB &#x3D; 2^10^MB，1MB &#x3D; 2^10^KB，1KB &#x3D; 2^10^B  (2^10^ &#x3D; 1024)</p><p>2^16^&#x3D;2^10^ ×2^6^ b &#x3D; 1024×64 &#x3D; 64kb</p><p>1字等于4b</p><p>b类分支指令：2^16字(256KB&#x2F;大概3000条指令)</p><p>j指令：2^26字(256MB)实现goto语句</p><p>jr指令：2^30字(4GB)跳的更远（全局范围）可以跳转到4GB内任意地址</p>]]></content>
      
      
      <categories>
          
          <category> BUAA课程学习 </category>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA_CO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>logisim基础</title>
      <link href="/2023/01/08/%E8%AE%A1%E7%BB%84/logisim%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/01/08/%E8%AE%A1%E7%BB%84/logisim%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Logisim学习笔记"><a href="#Logisim学习笔记" class="headerlink" title="Logisim学习笔记"></a>Logisim学习笔记</h1><h2 id="常用元器件"><a href="#常用元器件" class="headerlink" title="常用元器件"></a>常用元器件</h2><h3 id="Gates-门"><a href="#Gates-门" class="headerlink" title="Gates 门"></a>Gates 门</h3><h4 id="1-Odd-Parity-奇校验-x2F-Even-Parity-偶校验"><a href="#1-Odd-Parity-奇校验-x2F-Even-Parity-偶校验" class="headerlink" title="1.Odd Parity 奇校验&#x2F;Even Parity 偶校验"></a>1.Odd Parity 奇校验&#x2F;Even Parity 偶校验</h4><p>对于奇校验，若数据中有奇数个“1”，则校验结果为1，若数据中有偶数个“1”，则校验结果为0； 对于偶校验，若数据中有偶数个“1”，则校验结果为1，若数据中有奇数个“1”，则校验结果为0。</p><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081604500.png" alt="img"></p><h4 id="2-Controlled-Buffer-受控缓冲器-x2F-三态门"><a href="#2-Controlled-Buffer-受控缓冲器-x2F-三态门" class="headerlink" title="2.Controlled Buffer 受控缓冲器&#x2F;三态门"></a>2.Controlled Buffer 受控缓冲器&#x2F;三态门</h4><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081607286.png" alt="img"></p><h3 id="Plexers-复用器"><a href="#Plexers-复用器" class="headerlink" title="Plexers 复用器"></a>Plexers 复用器</h3><h4 id="1-Multiplexer-多路选择器-MUX"><a href="#1-Multiplexer-多路选择器-MUX" class="headerlink" title="1.Multiplexer 多路选择器 MUX"></a>1.Multiplexer 多路选择器 <strong>MUX</strong></h4><p>​        多路选择器将西面端口的输入复制到东面输出（多输入，一输出）。要输出哪个值是通过元件下端输入端口接收到的值确定的。</p><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081604507.png" alt="图1 多路选择器示例"></p><h4 id="2-Demultiplexer-解复用器-DMX"><a href="#2-Demultiplexer-解复用器-DMX" class="headerlink" title="2.Demultiplexer 解复用器 DMX"></a>2.Demultiplexer 解复用器 <strong>DMX</strong></h4><p>​        将西面边缘的输入复制到东面边缘的某个输出，是输出中哪一个是通过南侧的输入接收到的值指定的。</p><p>常用来写寄存器数据（给定一个地址输入信号，指定寄存器堆中的一个作为写入的目标寄存器</p><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081607490.png" alt="图2 解复用器示例"></p><h5 id="Three-state-三态选项"><a href="#Three-state-三态选项" class="headerlink" title="Three-state?三态选项"></a>Three-state?三态选项</h5><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081609348.png"><p>三态未开，DMX默认未被复制端为0，可输出</p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081604515.png" alt="image-20221002092347159" style="zoom: 67%;" /><p>三态开，DMX默认未被复制端为x，不可输出</p><h4 id="3-Decoder-译码器-Decd"><a href="#3-Decoder-译码器-Decd" class="headerlink" title="3.Decoder 译码器 Decd"></a>3.Decoder 译码器 Decd</h4><p>​       输出端从上到下编号，第一个编号为0。如果输出端的编号与当前通过南部的选择输入接收到的值相等，则这个端口的输出将为1，否则，它的值将是0或浮动，这取决于Three-State?（是否三态）属性。如果选择输入包含任何未指定的位，则所有输出都是浮动的。</p><p>三态功能同上</p><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081605460.png" alt="图3 译码器示例"></p><p><strong>真正的作用是将二进制编码转换为独热码。</strong></p><h4 id="4-Pirority-Encoder-优先编码器-Pri"><a href="#4-Pirority-Encoder-优先编码器-Pri" class="headerlink" title="4.Pirority Encoder 优先编码器 Pri"></a>4.Pirority Encoder 优先编码器 <strong>Pri</strong></h4><p>​        组件在其西边有多个输入，第一个输入编号为0，从上往下编号。该组件寻找值为1的输入的编号，并输出值最大的编号。例如，如果输入端编号为0、2、5和6的输入都是1，那么优先级编码器将输出 110（也就是编号6的二进制表示）。如果没有输入为1，或者组件被禁用，那么优先级编码器的输出是浮动的。</p><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081608536.png" alt="图4 优先编码器示例"></p><h4 id="5-Bit-Selector-位选择器-Sel"><a href="#5-Bit-Selector-位选择器-Sel" class="headerlink" title="5.Bit Selector 位选择器 Sel"></a>5.Bit Selector 位选择器 Sel</h4><p>​        给定一个 n 位的输入，将把输入分成几个大小相等的组(从最低阶位开始)。如果输出为 m 位，则一共分成 <img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081614558.gif" alt="\left \lceil \frac{n}{m} \right \rceil"> 组（但是编号从 0 开始），并输出选择输入所选择的组。(为什么公式lceil炫不出来？)<br> 例如，如果我们有一个 8 位的输入01010101，而我们要有一个 3 位的输出，那么8&#x2F;3向上取余&#x3D;3。0 组将是最低阶的 3 位 101，1 组将是接下来的 3 位 010，2 组将是接下来的 3 位 001（顶部以外的位用0填充)。选择输入的位宽将是 2，选择这三组中的哪一组输出，但如果选择输入是3，那么将输出 000</p><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081610902.png" alt="图5 位选择器示例"></p><h3 id="Arithmetic-运算器（部分）"><a href="#Arithmetic-运算器（部分）" class="headerlink" title="Arithmetic 运算器（部分）"></a>Arithmetic 运算器（部分）</h3><h4 id="1-Negator-取反器"><a href="#1-Negator-取反器" class="headerlink" title="1.Negator 取反器"></a>1.Negator 取反器</h4><p><strong>取输入的相反数补码输出</strong></p><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081605737.png" alt="img"></p><h4 id="2-Shifter-移位器"><a href="#2-Shifter-移位器" class="headerlink" title="2.Shifter 移位器"></a>2.Shifter 移位器</h4><p>逻辑左移</p><pre><code>    数据中的所有位向左移动 dist 位，底部空出的位用 0 填充。例如，11001011逻辑左移两次就是00101100（之前的右边两位丢弃）</code></pre><p>逻辑右移</p><pre><code>    数据中的所有位向右移动 dist 位，左端空出的位用 0 填充。例如，11001011逻辑右移两次就是00110010（之前的左边两位丢弃)</code></pre><p>算术右移</p><pre><code>    数据中的所有位向右移动 dist 位，左端空出的位用数据中最高位重复填充。例如，11001011算术右移两次就是11110010（之前最高位为 1，所以用 1 填充）</code></pre><p>循环左移</p><pre><code>    数据中的所有位都向左移动 dist 位，左边被“挤出去”的位填充到右边空出的位。例如，将11001011循环左移两次就是00101111。</code></pre><p>循环右移</p><pre><code>    数据中的所有位都向右移动 dist 位，右边被“挤出去”的位填充到左边空出的位。例如，将11001011循环右移两次就是11110010。</code></pre><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081604507.png" alt="img"></p><h4 id="3-Bit-Adder-逐位加法器"><a href="#3-Bit-Adder-逐位加法器" class="headerlink" title="3.Bit Adder 逐位加法器"></a>3.Bit Adder 逐位加法器</h4><p><strong>常用来计算输入中1位&#x2F;0位的数量</strong></p><p>逐位加法器计算并输出：输入中有多少位是<strong>1</strong>。</p><p>例如，给定8位输入10011101，输出将是5，因为在输入中有5个1位(第一个，最后一个，以及中间的一个由3位组成的字符串)。</p><p>逐位加法器可以有多个输入，表示多个输入中位为1的数量的总和</p><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081605920.png" alt="img"></p><h4 id="4-Bit-Finder-位查找器"><a href="#4-Bit-Finder-位查找器" class="headerlink" title="4.Bit Finder 位查找器"></a>4.Bit Finder 位查找器</h4><p><strong>功能：找位</strong></p><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081610809.png" alt="image-20221002095017254"></p><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081610656.png" alt="img"></p><h2 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h2><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081620872.png" alt="image-20220924153534626"></p><p>要点：</p><h3 id="Mealy型和Moore型"><a href="#Mealy型和Moore型" class="headerlink" title="Mealy型和Moore型"></a>Mealy型和Moore型</h3><h4 id="状态转移-x2F-次态逻辑无需考虑Mealy和Moore型的区别。"><a href="#状态转移-x2F-次态逻辑无需考虑Mealy和Moore型的区别。" class="headerlink" title="状态转移&#x2F;次态逻辑无需考虑Mealy和Moore型的区别。"></a>状态转移&#x2F;次态逻辑无需考虑Mealy和Moore型的区别。</h4><p>二者在输出逻辑上产生不同。</p><p>Mealy型输出逻辑：输出是状态和输入的函数。</p><p>Moore型输出逻辑：输出仅是状态的函数。</p><h4 id="Mealy-or-Moore"><a href="#Mealy-or-Moore" class="headerlink" title="Mealy or Moore?"></a>Mealy or Moore?</h4><p>Mealy型：输出窄、输出早。</p><p>以verilog指令为例: (state &#x3D;&#x3D; &#96;S3 &amp;&amp; input &#x3D;&#x3D; 1) ? 1:-1;</p><p>Moore型：输出信号宽。</p><p>以verilog指令为例: (state &#x3D;&#x3D; &#96;S4) ? 1:-1;</p><p>总结：</p><p>对输出信号宽度有要求：Moore型。</p><p>对输出信号时间有要求（越早越好）:Mealy型。</p><h2 id="使用时序电路实现函数计算"><a href="#使用时序电路实现函数计算" class="headerlink" title="使用时序电路实现函数计算"></a>使用时序电路实现函数计算</h2><p>常用形式为F(n)&#x3D;S(F(n-1),F(n-2),······)。思路是将当前值存在寄存器中，下一周期更新等价于实现一次推移。</p><p>以计算S(x) &#x3D; S(x-1) + S(x-2)&amp;S(x-3) 为例</p><h3 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h3><p>思想是S(x)在下一周期变为S(x-1),S(x-1)在下一周期变为S(x-2)…….依次类推。只存储需要用到的状态。（如题，用到S(x-1)，S(x-2)，S(x-3)）</p><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081605064.png" alt="image-20221003214013481"></p><h3 id="状态更新"><a href="#状态更新" class="headerlink" title="状态更新"></a>状态更新</h3><p>状态更新必然是组合逻辑。在三个计算状态更新后现状态应即可更新，等待下一次时钟沿的存储。</p><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081605566.png" alt="image-20221003214323092"></p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>相当于从负下标开始，逐步赋值。第一个周期，x&#x3D;0。后S(x)-&gt;S(x-1)，S(x-1)-&gt;S(x-2)，S(x-2)-&gt;S(x-3),</p><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081610987.png" alt="image-20221003214451581"></p><h2 id="常用组件搭配"><a href="#常用组件搭配" class="headerlink" title="常用组件搭配"></a>常用组件搭配</h2><h3 id="复位"><a href="#复位" class="headerlink" title="复位"></a>复位</h3><h4 id="异步复位"><a href="#异步复位" class="headerlink" title="异步复位"></a>异步复位</h4><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081611107.jpg" alt="Logisim异步复位到0"></p><p>当CLR（clear）为1时，reg直接变成0。</p><h4 id="同步复位"><a href="#同步复位" class="headerlink" title="同步复位"></a>同步复位</h4><h5 id="方式1：MUX接收同步reset信号"><a href="#方式1：MUX接收同步reset信号" class="headerlink" title="方式1：MUX接收同步reset信号"></a>方式1：MUX接收同步reset信号</h5><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081605749.jpg" alt="Logisim同步复位"></p><p>要求“在clk上升沿时复位”。</p><p>例：fsm</p><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081605365.png" alt="image-20221002101255735"></p><h5 id="方式2-寄存器实现reset信号与clk信号同频"><a href="#方式2-寄存器实现reset信号与clk信号同频" class="headerlink" title="方式2:寄存器实现reset信号与clk信号同频"></a>方式2:寄存器实现reset信号与clk信号同频</h5><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081605586.png" alt="image.png"></p><h3 id="赋初始值"><a href="#赋初始值" class="headerlink" title="赋初始值"></a>赋初始值</h3><p>有赋初始值需要的电路，通常认为第一个周期是赋初始值（注意各模块的同频），之后的周期进行运算。</p><h4 id="方式1：计数器-MUX"><a href="#方式1：计数器-MUX" class="headerlink" title="方式1：计数器+MUX"></a>方式1：计数器+MUX</h4><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081611218.png" alt="image-20221003184927702"></p><p>注意counter的设置。</p><h3 id="在输出正确结果前输出0，在得到正确结果后保持输出"><a href="#在输出正确结果前输出0，在得到正确结果后保持输出" class="headerlink" title="在输出正确结果前输出0，在得到正确结果后保持输出"></a>在输出正确结果前输出0，在得到正确结果后保持输出</h3><h4 id="在得到正确结果后保持输出"><a href="#在得到正确结果后保持输出" class="headerlink" title="在得到正确结果后保持输出"></a>在得到正确结果后保持输出</h4><p>增加计数模块</p><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081611950.png" alt="image-20221003210324794"></p><p>在周期数小于x时输出0，在周期数<strong>大于等于</strong>x时输出1。应注意比较器默认为有符号比较，一般需要调至无符号比较。</p><p>有两种选择：</p><ol><li>冻结计算逻辑寄存器(freeze信号传入计算逻辑，当周期到达后freeze反转传入寄存器使能端（默认传入冻结信号为1，使能端为0冻结）)</li><li>冻结输出MUX中的输入信号值，实现较为复杂。因为计数是在大于等于时freeze输出1，所以要保证freeze信号转为1时，传入信号仍能被更新进入MUX，下一周期才冻结。</li></ol><h4 id="在输出正确结果前输出0"><a href="#在输出正确结果前输出0" class="headerlink" title="在输出正确结果前输出0"></a>在输出正确结果前输出0</h4><p><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081611172.png" alt="image-20221003215129699"></p><p>只需让freeze在第x周期前为0，在第x周期及之后为1即可。用上文计数模块实现。</p><p>input的freeze需到计算逻辑中，增加freeze输入，放到寄存器使能端（记得取反）。</p><h2 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h2><h3 id="1-增加输入个数应同-2x"><a href="#1-增加输入个数应同-2x" class="headerlink" title="1.增加输入个数应同+2x"></a>1.增加输入个数应同+2x</h3><p>比如一个与门，现在有三个输入口，那么现在有增加指令的需求，三个输入口已不能满足需要，应增加输入，这时应增加为5个，可以避免重新接线。</p><p>同理，2个输入口应增加为4个&#x2F;6个</p><h3 id="2-善用Tunnel"><a href="#2-善用Tunnel" class="headerlink" title="2.善用Tunnel"></a>2.善用Tunnel</h3><p>可读性++</p><h3 id="3-善用快捷键"><a href="#3-善用快捷键" class="headerlink" title="3.善用快捷键"></a>3.善用快捷键</h3><p>数字键1-9输入引脚数</p><p>ctrl+1-9工具切换</p><p>alt+1-9位宽切换</p>]]></content>
      
      
      <categories>
          
          <category> BUAA课程学习 </category>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA_CO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>verilog基础</title>
      <link href="/2023/01/07/%E8%AE%A1%E7%BB%84/verilog%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/01/07/%E8%AE%A1%E7%BB%84/verilog%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h1><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><h4 id="未声明进制"><a href="#未声明进制" class="headerlink" title="未声明进制"></a>未声明进制</h4><p>默认十进制，一律被认为是有符号数。</p><h4 id="声明进制"><a href="#声明进制" class="headerlink" title="声明进制"></a>声明进制</h4><p>不声明符号则为无符号数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">8&#x27;sh51 //8位有符号数01010001</span><br><span class="line">6&#x27;so72 //6位有符号数111010，即十进制数下的-6</span><br><span class="line">4&#x27;d2 //4位无符号数</span><br><span class="line">&#x27;hAF //32位16进制数，无符号。注意未声明长度的，统一按32位长度处理</span><br></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>wire、reg不声明signed即为无符号。Integer不必也不允许声明符号，其中存储的二进制数本身就代表有符号数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wire [signed] [[msb:lsb]] net1;</span><br></pre></td></tr></table></figure><p>msb&#x2F;lsb:最高&#x2F;最低有效位</p><h3 id="有符号数和无符号数"><a href="#有符号数和无符号数" class="headerlink" title="有符号数和无符号数"></a>有符号数和无符号数</h3><p>可以使用 $signed 和 ￥unsigned系统函数控制操作数的符号行为。</p><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p><strong>只有右操作表达式中含有无符号数，就按照无符号数的方式运算！</strong></p><h3 id="不同位宽数据计算"><a href="#不同位宽数据计算" class="headerlink" title="不同位宽数据计算"></a>不同位宽数据计算</h3><h4 id="长位宽赋值给短位宽"><a href="#长位宽赋值给短位宽" class="headerlink" title="长位宽赋值给短位宽"></a>长位宽赋值给短位宽</h4><p>直接截断高位</p><h4 id="短位宽赋值给长位宽"><a href="#短位宽赋值给长位宽" class="headerlink" title="短位宽赋值给长位宽"></a>短位宽赋值给长位宽</h4><p>需要对高位进行位扩展，具体是扩展1还是扩展0，记住：<strong>完全依据右操作数!</strong></p><p>1）右操作数是无符号数，则无论左操作数是什么类型，高位都扩展成0；</p><p>2）右操作数是有符号数，则要看右操作数的符号位，按照右操作数的符号位扩展，符号位是1就扩展1，是0就扩展0；</p><p><strong>只有右操作表达式中含有无符号数，就按照无符号数的方式运算！</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wire [31:0] y1 = imm26[15:0];</span><br><span class="line">wire [31:0] y2 = $signed(imm26[15:0]);</span><br></pre></td></tr></table></figure><img src="https://cdn.staticaly.com/gh/Kafka-Hatsune/BlogCDN@main/img202301081435672.png" alt="image-20221123003953448" style="zoom:200%;" /><p>y1为零拓展，y2为符号拓展。</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><p>双目包括乘（*）、除（&#x2F;）、加（+）、减（-）、求幂（**）、取模（%）。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The forllowing are the arithmetic operators as defined by the Verilog language.</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//    + .... Addition</span></span><br><span class="line"><span class="comment">//    - .... Subtraction</span></span><br><span class="line"><span class="comment">//    * .... Multiplication</span></span><br><span class="line"><span class="comment">//    / .... Divide</span></span><br><span class="line"><span class="comment">//    % .... Modulus</span></span><br><span class="line"><span class="comment">//    ** ... Power Operator (i.e. 2**8 returns 256)</span></span><br></pre></td></tr></table></figure><ol><li><p>如果操作数某一位为 X，则计算结果也会全部出现 X。</p></li><li><p>对变量进行声明时，要根据变量的操作符对变量的位宽进行合理声明，不要让结果溢出。上述例子中，相加的 2 个变量位宽为 4bit，那么结果寄存器变量位宽最少为 5bit。<strong>否则，高位将被截断，导致结果高位丢失。</strong>乘除法同理，无符号数乘法时，结果变量位宽应该为 2 个操作数位宽之和。</p></li></ol><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] a,b;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">63</span>:<span class="number">0</span>] x = a*b;</span><br><span class="line"><span class="comment">/****或****/</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] hi,lo,a,b;</span><br><span class="line"><span class="keyword">assign</span> &#123;hi,lo&#125; = a*b;</span><br></pre></td></tr></table></figure><ol start="3"><li>溢出的判断</li></ol><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] AluRes;</span><br><span class="line"><span class="keyword">reg</span> Ov;</span><br><span class="line"><span class="comment">//in always</span></span><br><span class="line">&#123;msb, AluRes&#125; = &#123;A[<span class="number">31</span>], A&#125; + &#123;B[<span class="number">31</span>], B&#125;;</span><br><span class="line">Ov = (msb != AluRes[<span class="number">31</span>]);</span><br></pre></td></tr></table></figure><h4 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h4><h5 id="Verilog"><a href="#Verilog" class="headerlink" title="Verilog"></a>Verilog</h5><p>移位操作符包括左移（&lt;&lt;），右移（&gt;&gt;），算术左移（&lt;&lt;&lt;），算术右移（&gt;&gt;&gt;）。</p><p>移位操作符是双目操作符，两个操作数分别表示要进行移位的向量信号（操作符左侧）与移动的位数（操作符右侧）。</p><p>左移不区分逻辑和算术，都是右边低位会补 0。</p><p>右移区分逻辑和算术。<strong>逻辑右移时，左边高位会补 0；而算术右移时，左边高位会补充符号位，</strong>以保证数据缩小后值的正确性。</p><p>移位表达式（形如<code>i &gt;&gt;&gt; j</code>）的符号<strong>只</strong>由<code>i</code>的符号决定，<code>j</code>恒视作无符号且不参与该表达式的符号确定。</p><h5 id="补充：java"><a href="#补充：java" class="headerlink" title="补充：java"></a>补充：java</h5><p>因为mars的拓展指令需求class文件，所以需要搞清java与verilog的区别。</p><p>刚好与verilog相反，有符号右移为&gt;&gt;.无符号右移为&gt;&gt;&gt;。</p><p>因为java默认有符号数，verilog每个reg&#x2F;wire默认无符号数。</p><h4 id="位运算符-x2F-缩减运算符"><a href="#位运算符-x2F-缩减运算符" class="headerlink" title="位运算符&#x2F;缩减运算符"></a>位运算符&#x2F;缩减运算符</h4><p>同一组符号的运算符重载。做缩减运算符单目，做位运算符双目。</p><table><thead><tr><th>Operator</th><th>Description</th></tr></thead><tbody><tr><td>&amp;</td><td>and与</td></tr><tr><td>~&amp;</td><td>nand与非</td></tr><tr><td>|</td><td>or或</td></tr><tr><td>~|</td><td>nor或非</td></tr><tr><td>^</td><td>xor异或</td></tr><tr><td>^~ or ~^</td><td>xnor异或非</td></tr></tbody></table><p><strong>单目</strong>：将一个操作数的各个位进行运算。（（第一位op第二位）op第三位）·······</p><p>^:常用来计算一个数据中1的个数是奇数还是偶数，是奇数异或结果为1，是偶数异或结果为0。</p><p>（^data[9:0]) &#x3D;&#x3D; 1） iff data 9:0中1的个数是奇数 </p><p><strong>双目</strong>：将两个操作数的相应位进行与或等运算</p><p>不同长度的数据进行位运算，系统自动按右端对齐，位数少的高位补0，然后进行位运算</p><h4 id="等式运算符"><a href="#等式运算符" class="headerlink" title="等式运算符"></a>等式运算符</h4><h5 id="逻辑等式-x3D-x3D-x2F-x3D"><a href="#逻辑等式-x3D-x3D-x2F-x3D" class="headerlink" title="逻辑等式 &#x3D;&#x3D; &#x2F; !&#x3D;"></a>逻辑等式 &#x3D;&#x3D; &#x2F; !&#x3D;</h5><p>操作数中某些位是不定值和高阻态时结果可能为不定值x。其余同</p><h5 id="case等式-x3D-x3D-x3D-x2F-x3D-x3D"><a href="#case等式-x3D-x3D-x3D-x2F-x3D-x3D" class="headerlink" title="case等式 &#x3D;&#x3D;&#x3D;  &#x2F; ! &#x3D;&#x3D;"></a>case等式 &#x3D;&#x3D;&#x3D;  &#x2F; ! &#x3D;&#x3D;</h5><p>操作数中某些位是不定值和高阻态时也会进行比较，x&#x3D;x，z&#x3D;z输出1。其余同。主要用于某些情况下线路不定值和</p><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>&amp;&amp;和||和 ！</p><p>!：逻辑非，对一个数作用。</p><p>~：按位取反。</p><h4 id="位拼接运算"><a href="#位拼接运算" class="headerlink" title="位拼接运算"></a>位拼接运算</h4><ol><li>一个完整的拼接信号对应一个大括号。</li><li><strong>信号位宽必须明确，包括常量。</strong> （常被忽略，写成 {a,b,0},实际上应为{a,b,1’b0) )</li></ol><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;信号<span class="number">1</span>的某几位,信号<span class="number">2</span>的某几位......&#125;</span><br><span class="line">&#123;a,b[<span class="number">3</span>:<span class="number">0</span>],w,<span class="number">3&#x27;b101</span>&#125;</span><br><span class="line">&#123;<span class="number">4</span>&#123;w&#125;&#125;</span><br><span class="line">&#123;b,&#123;<span class="number">3</span>&#123;a,b&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h4><p>三目表达式<code>i ? j : k</code>中的<code>i</code>不参与该表达式的符号确定。</p><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><h4 id="wire连续赋值"><a href="#wire连续赋值" class="headerlink" title="wire连续赋值"></a>wire连续赋值</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wire      Cout, A, B ;</span><br><span class="line">assign    Cout  = A &amp; B ;     //实现计算A与B的功能</span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wire      A, B ;</span><br><span class="line">wire      Cout = A &amp; B ;</span><br></pre></td></tr></table></figure><p>在 wire 型变量声明的时候同时对其赋值。wire 型变量只能被赋值一次，因此该种连续赋值方式也只能有一次。不可再对Cout进行assign赋值。</p><p>个人认同并建议使用第二种写法，可以的话则将声明与赋值写于一起，简洁。但是仍需要注意，声明在使用前，不可在代码中先使用再声明。</p><h4 id="always块"><a href="#always块" class="headerlink" title="always块"></a>always块</h4><p>always块里赋值对象不能是wire型，只能是reg型</p><p>如果一个module的某个输出端口需要在always块中赋值：</p><ol><li>很多代码的做法是将该信号定义为wire类型，而同时在程序中再定义一个对应的reg型变量，在always模块中对后面这个定义的reg型变量赋值，而使用assign将reg型变量的值赋给输出端口。</li><li>将输出端口定义为reg型</li></ol><h4 id="阻塞非阻塞赋值"><a href="#阻塞非阻塞赋值" class="headerlink" title="阻塞非阻塞赋值"></a>阻塞非阻塞赋值</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">`timescale 1ns/1ns</span><br><span class="line"> </span><br><span class="line">module test ;</span><br><span class="line">    reg [3:0]   ai, bi ;</span><br><span class="line">    reg [3:0]   ai2, bi2 ;</span><br><span class="line">    reg [3:0]   value_blk ;</span><br><span class="line">    reg [3:0]   value_non ;</span><br><span class="line">    reg [3:0]   value_non2 ;</span><br><span class="line"> </span><br><span class="line">    initial begin</span><br><span class="line">        ai            = 4&#x27;d1 ;   //(1)</span><br><span class="line">        bi            = 4&#x27;d2 ;   //(2)</span><br><span class="line">        ai2           = 4&#x27;d7 ;   //(3)</span><br><span class="line">        bi2           = 4&#x27;d8 ;   //(4)</span><br><span class="line">        #20 ;                    //(5)</span><br><span class="line"> </span><br><span class="line">        //non-block-assigment with block-assignment</span><br><span class="line">        ai            = 4&#x27;d3 ;     //(6)</span><br><span class="line">        bi            = 4&#x27;d4 ;     //(7)</span><br><span class="line">        value_blk     = ai + bi ;  //(8)</span><br><span class="line">        value_non     &lt;= ai + bi ; //(9)</span><br><span class="line"> </span><br><span class="line">        //non-block-assigment itself</span><br><span class="line">        ai2           &lt;= 4&#x27;d5 ;           //(10)</span><br><span class="line">        bi2           &lt;= 4&#x27;d6 ;           //(11)</span><br><span class="line">        value_non2    &lt;= ai2 + bi2 ;      //(12)</span><br><span class="line">    end</span><br><span class="line"> </span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><p>程序只在某一个块中执行阻塞非阻塞。</p><p>语句（1）-（8）都是阻塞赋值，按照顺序执行。</p><p>进行（1）-（5）时，（8）为 X.</p><p>然后同一时序，逐步执行（6）（7），再执行（8）(使用前两步的值)。</p><p>然后执行并发块，（9）和（12）都使用并发块之前得出的值，而不使用并发块中得到的值。</p><h3 id="表达式中的符号性"><a href="#表达式中的符号性" class="headerlink" title="表达式中的符号性"></a>表达式中的符号性</h3><p>问题简介：在长的表达式中（一般为三目），若不管表达式的符号性，会导致原本期望有符号数的结果转化为无符号数的结果。</p><p>传递过程：先确定表达式整体的符号性，再将此符号性传递给所有子表达式，<strong>（自决定的子表达式不受影响）</strong>。类似递归的过程，遇到原子表达式则强制转换原子表达式的符号。</p><p>表达式符号确定原则：子表达式中任意一个被确定为无符号，那么整个表达式都被确定为无符号，否则有符号.</p><p>子表达式符号确定：</p><p>常量未声明进制默认十进制，一律被认为是有符号数。声明进制不声明符号则为无符号数。</p><p>某些运算符的符号性仅由其中部分操作数确定：移位运算符、三目运算符</p><p>例（BUAACO教程)：</p><blockquote><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> ? <span class="built_in">$signed</span>(a)&gt;&gt;&gt;b : <span class="number">4&#x27;b0</span></span><br></pre></td></tr></table></figure></blockquote><p><code>符号确定</code>：首先<code>1</code>不参与符号确定，排除；<code>$signed(a)&gt;&gt;&gt;b</code>和<code>4&#39;b0</code>，其中<code>4&#39;b0</code>显然无符号，<code>$signed(a)&gt;&gt;&gt;b</code>符号由<code>$signed(a)</code>决定，是有符号的；则表达式<code>1 ? 有符号 : 无符号</code>，由符号性传递，表达式整体无符号。</p><p><code>向内传播</code>：首先<code>1</code>不受影响，排除；原子表达式<code>4&#39;b0</code>本就是无符号，无需转换；<code>$signed(a)&gt;&gt;&gt;b</code>中<code>b</code>不受影响，再次递归进入<code>$signed(a)</code>，是有符号原子表达式，强制转化成无符号，即<code>$unsigned($signed(a))</code>。</p><p>最终表达式等价<code>a &gt;&gt; b</code>，相当于仍对<code>a</code>进行逻辑右移。</p><h4 id="写代码的解决方法"><a href="#写代码的解决方法" class="headerlink" title="写代码的解决方法"></a>写代码的解决方法</h4><ol><li>分离变量法</li></ol><p>声明变量可以防止向内传播。</p><pre><code>wire [31:0]lshift;      //逻辑移位wire [31:0]ashift;      //算术移位assign lshift = $signed(A)&gt;&gt;B;assign ashift = $signed(A)&gt;&gt;&gt;B;assign C = (ALUOp==3&#39;b000)? A+B:            (ALUOp==3&#39;b001)? A-B:            (ALUOp==3&#39;b010)? A&amp;B:            (ALUOp==3&#39;b011)? A|B:            (ALUOp==3&#39;b100)? lshift:            (ALUOp==3&#39;b101)? ashift:            (ALUOp==3&#39;b110)? ((A&gt;B)?1:0):            (ALUOp==3&#39;b111)? (($signed(A)&gt;$signed(B))?1:0):            0;</code></pre><ol start="2"><li>$signed隔断</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">assign C = (ALUOp==3&#x27;b000)? A+B:</span><br><span class="line">            (ALUOp==3&#x27;b001)? A-B:</span><br><span class="line">            (ALUOp==3&#x27;b010)? A&amp;B:</span><br><span class="line">            (ALUOp==3&#x27;b011)? A|B:</span><br><span class="line">            (ALUOp==3&#x27;b100)? lshift:</span><br><span class="line">            (ALUOp==3&#x27;b101)? $signed($signed(A)&gt;&gt;&gt;B):</span><br><span class="line">            (ALUOp==3&#x27;b110)? ((A&gt;B)?1:0):</span><br><span class="line">            (ALUOp==3&#x27;b111)? (($signed(A)&gt;$signed(B))?1:0):</span><br><span class="line">            0;</span><br></pre></td></tr></table></figure><h3 id="函数用法"><a href="#函数用法" class="headerlink" title="函数用法"></a>函数用法</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> &lt;返回值的类型或范围&gt;(函数名);</span><br><span class="line">    &lt;端口说明语句&gt;          <span class="comment">// input XXX</span></span><br><span class="line">    &lt;变量类型说明语句&gt;      <span class="comment">// reg YYY</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        &lt;语句&gt;</span><br><span class="line">        ......</span><br><span class="line">        函数名 = ZZZ;       <span class="comment">// 函数名就相当于输出变量;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure><p>函数的目的是返回一个用于表达式的值。</p><p>函数的定义不能包含任何的时间控制语句。它是个时序逻辑。</p><p>定义函数时必须要有一个输入参量</p><p>函数的结果值应存放在与函数名同名的内部变量中且必须赋值。</p><p>例</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#定义</span><br><span class="line"><span class="keyword">function</span>[<span class="number">31</span>:<span class="number">0</span>]factorial #返回值:[<span class="number">31</span>:<span class="number">0</span>]寄存器（默认）</span><br><span class="line">    <span class="keyword">input</span>[<span class="number">3</span>:<span class="number">0</span>]in_data;#函数输入参数</span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>]index;#函数内部用寄存器</span><br><span class="line">    <span class="keyword">begin</span>#开始定义</span><br><span class="line">        factorial=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(index=<span class="number">2</span>;index&lt;=in_data;index=index+<span class="number">1</span>)</span><br><span class="line">            factorial=index*factorial;</span><br><span class="line">    <span class="keyword">end</span>#结束定义</span><br><span class="line"><span class="keyword">endfunction</span>#结束函数</span><br><span class="line"></span><br><span class="line">#使用</span><br><span class="line">result = factorial(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h3 id="for循环用法"><a href="#for循环用法" class="headerlink" title="for循环用法"></a>for循环用法</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> i;<span class="comment">//注意integer申明在always外面</span></span><br><span class="line"><span class="keyword">always</span>@(*)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX; i = i + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// do what u want</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>for循环一般在组合逻辑中作为一种函数出现，和always(*)相伴，如果不放在always块中，而是直接出现，<br>会报错。</li><li>for循环一般用于计数，而计数时，会有中间变量，那么每次启动for循环用于计数时，要保证中间变量被清零了。</li></ol><p>例：附上一个正常的计数代码段，功能是判断RegRead1这个wire里“1”的个数是不是奇数：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> odd;   <span class="comment">// is odd??</span></span><br><span class="line"><span class="keyword">reg</span>[<span class="number">31</span>:<span class="number">0</span>] num;   <span class="comment">// how many &quot;1&quot; in RegRead1??</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">integer</span> i;</span><br><span class="line"><span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line">    num = <span class="number">0</span>;    </span><br><span class="line">    <span class="comment">// loop start, intermediate variable set to 0</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i = i + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(RegRead1[i] == <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">            num = num + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">assign</span> odd = num[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h1 id="TestBench"><a href="#TestBench" class="headerlink" title="TestBench"></a>TestBench</h1><p>本质也是个.v文件。调用要测试的模块喂数据出波形图。</p><h2 id="finish"><a href="#finish" class="headerlink" title="$finish"></a>$finish</h2><p>在initial末尾（end前）加上<code>$finish;</code>可有效减少模拟时间。</p><h2 id="时钟周期"><a href="#时钟周期" class="headerlink" title="时钟周期"></a>时钟周期</h2><p>创建一个周期为10单位的时钟</p><p>&#96;timescale 1ns &#x2F; 1ps 一单位时间为1ns。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span> </span><br><span class="line">   <span class="keyword">begin</span></span><br><span class="line">        clk = <span class="number">0</span>;</span><br><span class="line">        ......</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">......</span><br><span class="line"><span class="keyword">always</span> #<span class="number">5</span> clk = ~clk</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> BUAA课程学习 </category>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA_CO </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* ҳ����ͷͼ͸�� */#footer {    background: transparent !important;}#page-header {    background: transparent !important;}/* ����ģʽ����͸�� */#footer::before {    background: transparent !important;}#page-header::before {    background: transparent !important;}/* ҹ��ģʽ����͸�� */[data-theme="dark"] #footer::before {    background: transparent !important;}[data-theme="dark"] #page-header::before {    background: transparent !important;}/* �����������Ϣ��Ƭ��̬����ɫ */#aside-content>.card-widget.card-info {    background: linear-gradient(-45deg,            #e8d8b9,            #eccec5,            #a3e9eb,            #bdbdf0,            #eec1ea);    box-shadow: 0 0 5px rgb(66, 68, 68);    position: relative;    background-size: 400% 400%;    -webkit-animation: Gradient 10s ease infinite;    -moz-animation: Gradient 10s ease infinite;    animation: Gradient 10s ease infinite !important;}@-webkit-keyframes Gradient {    0% {        background-position: 0% 50%;    }    50% {        background-position: 100% 50%;    }    100% {        background-position: 0% 50%;    }}@-moz-keyframes Gradient {    0% {        background-position: 0% 50%;    }    50% {        background-position: 100% 50%;    }    100% {        background-position: 0% 50%;    }}@keyframes Gradient {    0% {        background-position: 0% 50%;    }    50% {        background-position: 100% 50%;    }    100% {        background-position: 0% 50%;    }}/* ��ҹģʽ���� */[data-theme="dark"] #aside-content>.card-widget.card-info {    background: #191919ee;}/* ������ϢFollow me��ť */#aside-content>.card-widget.card-info>#card-info-btn {    background-color: #3eb8be;    border-radius: 8px;}]]></content>
      
    </entry>
    
    
  
</search>
